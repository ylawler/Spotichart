## General evaluation

- completed original goals, adapted to the situation and added PCA
- [used KanBan](https://gitlab.ewi.tudelft.nl/ewi3615tu/2019-2020/data/ewi3615tu-ds10/ewi3615tu-ds10/blob/master/Documentation%20set/Evaluation/KanBan_Board.jpg) 
- all learned a lot about k means and k nearest , supervised vs unsupervised algorithms
- 


At the beginning of the project, our group was not very sure on what to do and what was expected of us. Drawing up a complete development and design plan felt a bit foreign to us, after a complete project that focussed on short sprints and quick deliverables. However, while we built the foundations for our project's structure and thought out the necessities to acquire our goal, we did not stand still. Packages were tested and algorithms were fitted to our destination, which saved a lot of time during the implementation phase. We also noticed that the fact that we had so clearly structured the software in our development plan accelerated our pace throughout implementation. 

Even though the overview we had through our carefully thought-out structure gave us grip in the development of our project, we did decide we wanted to divide the work up to keep ourselves focussed each week. We used [KanBan](https://gitlab.ewi.tudelft.nl/ewi3615tu/2019-2020/data/ewi3615tu-ds10/ewi3615tu-ds10/blob/master/Documentation%20set/Evaluation/KanBan_Board.jpg) to keep sight on our To-do's and to push them through testing phase onto the "done" stack along structured lines. We divided up the work each week and had clearly scheduled the moment we would be working on the project together, which managed all of our expectations and made sure we could finish the work in time and had questions to ask our TA. The scheduled sessions ran smoothly and the atmosphere in our group throughout the project was (sometimes too) good.

Following our development plan, we did run into some issues we could not have foreseen before the implementation of our software. We found out that the K-nearest-neighbour would be less suited to our needs than the K-means algorithm, which is why we altered our plan slightly. In the process of looking into these algorithms, we learned a great deal about machine learning and . The overal grip of the predefined design plan gave us a good footing to alter decisions we had made earlier, as we knew how those would be nested in our program as a whole. Another example was the visualisation of our minimum spanning tree. As we assessed Spotify songs based on so many audio features, the clusters found were not very distinct and our minimum spanning tree did not show them well. To solve this issue, we decided to visualise the MST in 3D and to use PCA to scale back the dimensions that had to be shown. In the end, the minimum spanning tree was interpretable by sight. 

To conclude, we had a clear plan to stick to but were not scared to alter it slightly for the better. The predefined structure helped us cluster our own work on a weekly basis and in an unambiguous way. Our group work ran smoothly, although the fun we had sometimes stood in the way of otherwise very efficiently scheduled working sessions.

- 3D mst -> wrong, did not use mst in the end. Did output it but clusters visualised in 3d through pca
- last sentence!!
- k nearest learning stuff
- remove bullet points


## Individual evaluations

*Yannick*

I understood the process of developing a software a lot better during this project. It was a lot clearer from the beginning what processes to use to stay organized and develop a good software. This made it easier, and we worked on different diagrams from the beginning which made it easier to know what we had to work on. For example, with a class diagram we made in the beginning, everyone knew what our code will look like. Everyone worked really well, and all of our project sessions were a lot of fun. We managed to keep up a good working pace, but also have a good time. 

As for myself, I believe I was able to open up and be more talkative than in other group projects I've been apart of. Furthermore, I managed to learn a lot more about coding, and hence improve my coding skills. However, I believe I could still try to say my opinion more and try to take on a leadership role.

*Renske*

During this project, I was amazed by how steep my learning curve was during this minor. In our first project that was part of the course Software Engineering and Methods, we spent very large amounts of time on trying to fix bugs and changing our code design. Now that we worked with predefined classes and a very clear design plan, I noticed a lot of these problems were prevented. Writing code went a lot faster since we actually knew beforehand for each method what we wanted our output to be and how we roughly wanted to do it. This also made it a lot easier to work on different parts of code seperately. I felt much more confident on starting with a problem not really knowing how to do it and just searching for information until I had figured out a way. 

Besides the aspects mentioned in the general project evaluation, I have also learned about my personal behaviour. In projects I have a strong desire to do well and deliver nice results. I really like to have a clear idea of who is working on what part and to have structure. This resulted in me often taking the lead, which I think the other team members liked as well and helped us working more efficiently. 

However, halfway, I mentioned that sometimes I could become too dominant, impatient or a little too negative towards other group members. I tried to change this by listening better to other members of the group and being more careful with giving feedback. I feel like I was succesfully able to change this and I felt better about myself when I came home after the group sessions. Although the other group members may have not even noticed the difference, I am really happy I was able to reflect and work on my behaviour in this way. I think it is an important thing for me to keep in mind while working on future projects. 




*Julian*

From my perspective, this project went smoother than the previous project. This was due to more experience with coding and working on such a project. We used trello as a Kanban which was very helpful for me to have a good overview of the project. The tasks were divided each week and it was very clear what was expected from each other. My weak point is still the coding part, so I learned a lot from group members who didn’t have as much struggles as I have. Also I’m happy with the results we got. We can see that our algorithm can cluster the playlists well to a certain extend. It was actually harder than expected, because of the many dimensions we had to cope with. Luckily, we learned a lot about the ‘curse of dimensionality’ in the other courses so we came with solutions to still cluster and visualize the results. 

As for the feedback on myself, I would like to code more in the future. Now, the group members who are more experienced with python did most of the coding. Also, I want to do more preparation before coming to the project hours so I’m confident about what I say and what I do. 


*Bart*

For me personally this project was vastly different than the last one we did. During this project we were told to make a design plan and a development plan at the start of the project and stick to it. While during the last project we were told to do these steps iterative. This was a bit strange at the start but eventually I got used to it and I’m glad with the results we have in the end. 

As for feedback on myself, I feel like I did more research and documentation than the actual coding, which I don’t mind. For next projects I would like to do more of the coding, however I learned a lot about all of the algorithms as mentioned in the general evaluation


*Quirine*

During this project, I noticed I felt a bit reluctant to plan everything ahead. In our last project, the focus lay on doing short sprints and delivering quick results. At first, it felt as though the thorough documentation we had to draw up and the thought we had to put into structure was holding us back a bit, but in the end it ran a common thread through our project as a whole. Especially when we decided to already experiment with some of the modules we used throughout the project, it quickened the process. 

For myself, I did notice that at many moments I could not keep up with the programming, on which I would have liked to help more. However, in writing tests I did add some thought to the process and can say that my insight in what to do in most cases has improved. The algorithms we used for our software have definitely added to my programming knowledge and skills overall.